---
layout: default
title: REST APIs
parent: Coding Guidelines
nav_order: 7
---

# REST APIs Coding Guidelines

Welcome to the Mobile 2.0 API coding guidelines. Here you can find the coding guidelines and standards for API Development. This document is just a complimentary guide to our [BMW API Guidelines](http://developer.bmw.com/connected-vehicle/develop/guides-and-tutorials/api-guides/).

All these guidelines follow the spirit of our **api coding values**. Our APIs:

* are easy to learn and understand
* are generic and abstracted from specific implementation and use cases
* are robust and easy to use
* have a consistent look and feel
* follow a consistent RESTful style and syntax
* are unified across teams and throughout the organization

## API First cycle

![api first cycle]({{site.baseurl}}/assets/images/api-first-cycle.png)

The lifecycle of API development has three phases:

1. **Design and review**: before doing any coding work, it is mandatory to start with an Open API document with your API design. Share with your team and your PO. Make sure your APIs are supporting the business case. Make sure your API adheres to our standards. 
2. **Publish, mock and testing**: once the design has been reviewed and validated, get your tests ready. Even [contract tests](https://martinfowler.com/bliki/ContractTest.html). After that, provide mock/sample data to the API, so you can start having clients consuming the API. You will get feedback almost 100% of the time. Adapt the changes.
3. **Build**: the last step is to build your APIs. Implementation details should never be known be the clients. Clients should not care if it is a microservice or a monolith, .NET or NodeJS, or if it is hosted in AWS or Azure. Do more testing, and make sure your tests from phase 1 and 2 pass too.

### Swagger / Open API

Use OpenAPI to design and document; Swagger and its toolset should be use to generate the documentation. While the developer portal specifies to use v2 of Swagger, it is fine to use newer versions of OpenAPI/Swagger if needed.

PS. If you are confused about what is OpenAPI and/or Swagger, please read this: [What Is the Difference Between Swagger and OpenAPI?](https://swagger.io/blog/api-strategy/difference-between-swagger-and-openapi/)

## Presentation vs Core APIs

TO BE COMPLETED!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

## HTTP methods

[Developer Portal: HTTP Status Codes and Operations](http://developer.bmw.com/connected-vehicle/develop/guides-and-tutorials/api-guides/#http-status-codes-and-operations)

In a REST API world, we model our objects as resources with the use of URIs and JSON, for example, and we define `actions using HTTP verbs`. Therefore, in a REST endpoint definition, the URL should never include a verb in it; it is the responsibility of the HTTP method being used to express an operation to be executed. 

Safe methods are HTTP methods that do not modify resources.

An idempotent HTTP method is a HTTP method that can be called many times without different outcomes. It would not matter if the method is called only once, or ten times over. The result should be the same. This only applies to the result, not the resource itself. 

The HTTP methods recommended to use are:

* `DELETE`: use it for destructive operations, such as deleting a resource, or canceling an event in progress. 
  * It is **not a safe** operation, since it modifies content.
  * It is an **idempotent** operation, since executing the same operation multiple times will have the same effect on the server side.
* `GET`: used to retireve a single resource, or a collection of resources.
  * It is a **safe** operation.
  * It is an **idempotent** operation.
* `POST`: use it to request the creation of a resource that does not exist yet.
  * It is **not a safe** operation.
  * It is **not an idempotent** operation.
* `PUT`: used to update, replace or modify existing resources.
  * It is **not a safe** operation.
  * It is an **idempotent** operation.

## HTTP Codes

[Developer Portal: HTTP Status Codes and Operations](http://developer.bmw.com/connected-vehicle/develop/guides-and-tutorials/api-guides/#http-status-codes-and-operations)

These are the most used codes for REST APIs. Use them in the right context, and in the right way, as described. If you need something that does not fit in here, then you might need to use a different code with its own meaning. This operation should not be taken lightly, since it is not predictable. If you have no choice, make sure you provide superb documentation about it.

### `2xx` for success

* `200 OK`: The standard HTTP response representing success for `GET`, `PUT` or `POST`.

### `4xx` for client errors

PS. *Client* here is used as a consumer of the API, not necessarily a GUI client.

* `400 Bad Request`: the request generated by the client cannot be processed because the server could not understand it. It usually means that the request was malformatted.
* `401 Unauthorized`: the client is not allowed to access the resource.
* `403 Forbidden`: the client has generated a valid request, but the authentication credentials are not valid anymore. This indicates that new "tokens" need to be issued.
* `404 Not Found`: the resource requested is not avaiable, or does not exist at that given point in time.

### `5xx` for backend errors

* `500 Internal Server Error`: the backend is down. Needs to be fixed on the server side. I hope you never find one of this.
* `503 Service Unavailable`: the server is down, but under maintenance. 

## Resource Modeling

> The key abstraction of information in REST is a resource. Any information that can be named can be a resource: a document or image, a temporal service (e.g. "today's weather in Los Angeles"), a collection of other resources, a non-virtual object (e.g. a person), and so on. In other words, any concept that might be the target of an author's hypertext reference must fit within the definition of a resource. A resource is a conceptual mapping to a set of entities, not the entity that corresponds to the mapping at any particular point in time

-> **[Roy Fielding’s dissertation, originator of the REST architectural approach](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_2_1_1)**

Resources are the core concept of any REST API. We can identify these components:

* API operations (HTTP methods) to describe the action to be performed.
* Resource identifiers, or URIs, that represent the full URL of the endpoint.
* Resource representation, or JSON payload, to describe the object(s) needed. 

### URIs - Resource Identifiers

URIs, also called endpoints, are used to identify the resource that you want to access. In a way, it is like the method name in an object oriented programming language.

#### Only include what matters

A URI is something that identifies your resource. Getting the naming right is critical, since an API, in order to be friendly and clean, **MUST BE PREDICTABLE**, and remove unnecessary elements. An example of this could be:

GOOD: `/v1/vehicles/{vin}`

BAD: `/controller/dotnet/v1/vehicleService/vehicles/singleVehicle/{vin}`

As you can see, the first example is concise, clear and predictable. It hides implementation details that the client does not need to know, and it follows a hierarchy.

> A resource identifier **MUST** contain only the necessary elements to identify the resource, and no more.

#### Plural vs. singular nouns

A resource should always be identified as a plural noun, and then access a singular by identifier.

If the resource cannot be ever treated as a collection, then it is fine to use a singular noun, since it is still predictable.

Good examples:

```
GET /vehicles
GET /vehicles/{vin} (this is how to access a single vehicle)
GET /trips
GET /trips/{tripId} (this is how to access a single trip)
GET /vehicles/{vin}/steering_wheel (a vehicle only has one steering wheel)
GET /birth_date (you can only have one birth date)
```

#### Relationships

Resources can have relationships between them, or subcollections. These can be identified also as part of the URI. 

For example, in a banking context, if you want to know the accounts opened by a customer, you would model it like: `GET /customers/{customerId}/accounts`.

Similarly, you access a single account for that given customer like `GET /customers/{customerId}/accounts/{accountId}`.

> The starting point in selection of resources is to analyze your business domain and extract the nouns that are relevant to your business needs. More importantly, focus should be given to the needs of API consumers and how to make the API relevant and useful from the perspective of API consumer interactions. Once the nouns (resources) have been identified, then the interactions with the API can be modeled as HTTP verbs against these nouns. When they don't map nicely, we could approximate. For example, we can easily use the “nouns in the domain” approach and identify low level resources such as Post, Tag, Comment, etc. in a blogging domain. Similarly, we can identify the nouns Customer, Address, Account, Teller, etc. as resources in a banking domain.

#### What goes in the path, and what is a query parameter

Elements of the URI are used to described hierarchical structures. Therefore, this endpoint:

```
GET /customers/{customerId}/accounts
```

means: "Give me the accounts for the customer with customer ID = {customerId}". 

However, [query parameters](https://tools.ietf.org/html/rfc3986#section-3.4) **contain non-hierarchical data** that, along with the data in the path, serves to identify a resource withing the scope of the URI's scheme and naming authoritiy.

Therefore, if in the previous example, if we want to sort the accounts of the given customer by `created_at`, we could use a query parameter like this:

```
GET /customers/{customerId}/accounts?sort_by=created_at&order_by=asc
```

Or, if we wanted to only get checking accounts, we could use a query parameter to indicate the type of filter:

```
GET /customers/{customerId}/accounts?account_type=checking
```